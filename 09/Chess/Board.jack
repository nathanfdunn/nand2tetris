class Board {
    field Array ranks;

    field boolean hasChanges;

    static boolean debug;

    // static int boardDim;

    function void init() {
        let debug = true;
        return;
    }

    // function boolean getDebug() {
    //     return debug;
    // }

    method boolean getHasChanges() {
        return hasChanges;
    }

    method void acknowledgeChanges() {
        let hasChanges = false;
        return;
    }

    method void touch() {
        let hasChanges = true;
        return;
    }

    constructor Board new(){
        var int i;
        var Array temp;
        let i = 0;
        let ranks = Array.new(8);

        let hasChanges = true;

        while (i < 8){
            let ranks[i] = Array.new(8);
            let i = i + 1;
        }

        if (debug) {
            let temp = ranks[Main.getX()];
            let temp[Main.getY()] = Piece.knight(true);
        }
        else {
            let temp = ranks[0];
            let temp[0] = Piece.rook(false);
            let temp[1] = Piece.knight(false);
            let temp[2] = Piece.bishop(false);
            let temp[3] = Piece.queen(false);
            let temp[4] = Piece.king(false);
            let temp[5] = Piece.bishop(false);
            let temp[6] = Piece.knight(false);
            let temp[7] = Piece.rook(false);

            let temp = ranks[1];
            let temp[0] = Piece.pawn(false);
            let temp[1] = Piece.pawn(false);
            let temp[2] = Piece.pawn(false);
            let temp[3] = Piece.pawn(false);
            let temp[4] = Piece.pawn(false);
            let temp[5] = Piece.pawn(false);
            let temp[6] = Piece.pawn(false);
            let temp[7] = Piece.pawn(false);

            let temp = ranks[6];
            let temp[0] = Piece.pawn(true);
            let temp[1] = Piece.pawn(true);
            let temp[2] = Piece.pawn(true);
            let temp[3] = Piece.pawn(true);
            let temp[4] = Piece.pawn(true);
            let temp[5] = Piece.pawn(true);
            let temp[6] = Piece.pawn(true);
            let temp[7] = Piece.pawn(true);

            let temp = ranks[7];
            let temp[0] = Piece.rook(true);
            let temp[1] = Piece.knight(true);
            let temp[2] = Piece.bishop(true);
            let temp[3] = Piece.queen(true);
            let temp[4] = Piece.king(true);
            let temp[5] = Piece.bishop(true);
            let temp[6] = Piece.knight(true);
            let temp[7] = Piece.rook(true);
        }

        return this;
    }

    method boolean isEven(int blah){

        return (blah - (2 * (blah / 2))) > 0;
    }

    method void makeMove(Move move) {
        // TODO add validation that the move is legal and even exists
        var Array rank;
        var Piece piece;

        let rank = ranks[move.getStartRank() - 1];
        let piece = rank[move.getStartFile() - 1];
        let rank[move.getStartFile() - 1] = 0;

        // TODO dispose of the piece that was there
        let rank = ranks[move.getEndRank() - 1];
        let rank[move.getEndFile() - 1] = piece;

        let hasChanges = true;

        return;
    }

    method void print(){
        var int i;
        var int j;
        var Array rank;
        var Piece piece;
        var boolean color;
        var boolean squareColor;
        var int dim;
        var int x1;
        var int x2;
        var int y1;
        var int y2;

        let i = 0;
        let color = true;
        let dim = 32;

        while (i < 8){
            let j = 0;
            while (j < 8){
                let squareColor = ~isEven(i + j);
                let color =squareColor;
                do Screen.setColor(color);
                // Add 8 to draw the board on the right side
                let x1 = (j + 8) * dim;
                // 7 - i so that we draw from white's perspective
                let y1 = (7 - i) * dim;
                let x2 = x1 + dim;
                let y2 = y1 + dim;

                do Screen.drawRectangle(x1, y1, x2-1, y2-1);

                let rank = ranks[i];
                let piece = rank[j];
                //do Screen.drawRectangle(x1, y1)
                if (~(piece = 0)){
                    do piece.draw(x1, y1, squareColor);
                }

                let j = j + 1;
            }

            let i = i + 1;
        }

        return;
    }

    method Piece getPieceAt(int x, int y) {
        var Array rank;
        let rank = ranks[y];
        return rank[x];
    }

    method Piece getPieceAtSquare(Square square) {
        return getPieceAt(square.getX(), square.getY());
    }


    // TODO remove?    
    method void printLegalMovesAt() {    
        var List moves;
        var int index;
        var Square square;
        var int x;
        var int y;

        let x = Main.getX();
        let y = Main.getY();

        do Output.printInt(x);
        do Output.printString(",");
        do Output.printInt(y);
        do Output.println();

        let moves = getLegalMovesAt(x, y);

        if (moves = 0) {
            do Output.printString("NULL");
        }
        else {
            let index = moves.getLength() - 1;
            while (index > -1) {
                let square = moves.getElement(index);
                do Output.printString(square.toString());
                do Output.println();
                
                let index = index - 1;
            }
        }

        return;
    }



    // x, y is in 0-based coordinates
    // TODO return Moves instead of Squares
    // TODO put this in SquareGenerator or maybe even a different class
    method List getLegalMovesAt(int x, int y) {
        var List offsets;
        var Piece piece;
        var Square pos;
        var List ret;
        var Square potentialSquare;
        var Piece otherPiece;
        var int dirIndex;
        var int dirCount;
        var int dirDist;
        var int riderDist;

        let piece = getPieceAt(x, y);

        if (piece = 0) {
            return 0;
        }

        let ret = List.empty();

        let pos = Square.fromBoardIndices(x, y);

        let offsets = SquareGenerator.getOffsetsByPiece(piece);

        let riderDist = SquareGenerator.getRiderDistForPiece(piece);

        let dirCount = Math.divide(offsets.getLength(), riderDist);
        let dirIndex = 0;

        // do Util.printLineInt(dirCount);

        // do Util.printLineInt(offsets.getLength());

        while (dirIndex < dirCount) {
            let dirDist = 0;
            while (dirDist < riderDist) {
                // do Util.printLineInt(Math.multiply(dirDist, dirCount) + dirIndex);
                let potentialSquare = offsets.getElement(Math.multiply(dirDist, dirCount) + dirIndex);
                let potentialSquare = pos.addSquare(potentialSquare);

                // do Util.printLineString("potential:");
                // do Util.printLineString(potentialSquare.toString());
                // if (potentialSquare = 0) {
                // do Util.printLineInt(dirDist);
                // do Util.printLineInt(dirCount);
                // do Util.printLineInt(dirIndex);
                // do Util.alertIfNull(potentialSquare);
                // }


                if (~potentialSquare.isOnBoard()) {
                    // break;
                    let dirDist = riderDist;
                }
                else {
                    let otherPiece = getPieceAtSquare(potentialSquare);

                    if (otherPiece = 0) {
                        // All good, and can keep going
                        do ret.append(potentialSquare);
                        let dirDist = dirDist + 1;
                    }
                    else {
                        if (piece.isEnemy(otherPiece)) {
                            // Hey a capture! Can't go past this though
                            do ret.append(potentialSquare);
                            let dirDist = riderDist;        // break;
                        }
                        else {
                            // Can't capture friendly piece, we're blocked
                            let dirDist = riderDist;        // break;
                        }
                    }
                }
            }

            let dirIndex = dirIndex + 1;
        }
        
        return ret;
    }

    method Array getPotentialSquares(Square pos, Array offsets, int offsetsLength) {
        var Array ret;
        let ret = Array.new(offsetsLength);

        let offsetsLength = offsetsLength - 1;
        while (offsetsLength > -1) {
            let ret[offsetsLength] = pos.addSquare(offsets[offsetsLength]);
            let offsetsLength = offsetsLength - 1;
        }

        return ret;
    }

}