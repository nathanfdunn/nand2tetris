class Board {
    field Array ranks;

    field boolean hasChanges;

    static boolean debug;

    // static int boardDim;

    function void init() {
        let debug = true;
        return;
    }

    // function boolean getDebug() {
    //     return debug;
    // }

    method boolean getHasChanges() {
        return hasChanges;
    }

    method void acknowledgeChanges() {
        let hasChanges = false;
        return;
    }

    method void touch() {
        let hasChanges = true;
        return;
    }

    constructor Board new(){
        var int i;
        var Array temp;
        let i = 0;
        let ranks = Array.new(8);

        let hasChanges = true;

        while (i < 8){
            let ranks[i] = Array.new(8);
            let i = i + 1;
        }

        if (debug) {
            let temp = ranks[3];
            let temp[3] = Piece.knight(true);
        }
        else {
            let temp = ranks[0];
            let temp[0] = Piece.rook(false);
            let temp[1] = Piece.knight(false);
            let temp[2] = Piece.bishop(false);
            let temp[3] = Piece.queen(false);
            let temp[4] = Piece.king(false);
            let temp[5] = Piece.bishop(false);
            let temp[6] = Piece.knight(false);
            let temp[7] = Piece.rook(false);

            let temp = ranks[1];
            let temp[0] = Piece.pawn(false);
            let temp[1] = Piece.pawn(false);
            let temp[2] = Piece.pawn(false);
            let temp[3] = Piece.pawn(false);
            let temp[4] = Piece.pawn(false);
            let temp[5] = Piece.pawn(false);
            let temp[6] = Piece.pawn(false);
            let temp[7] = Piece.pawn(false);

            let temp = ranks[6];
            let temp[0] = Piece.pawn(true);
            let temp[1] = Piece.pawn(true);
            let temp[2] = Piece.pawn(true);
            let temp[3] = Piece.pawn(true);
            let temp[4] = Piece.pawn(true);
            let temp[5] = Piece.pawn(true);
            let temp[6] = Piece.pawn(true);
            let temp[7] = Piece.pawn(true);

            let temp = ranks[7];
            let temp[0] = Piece.rook(true);
            let temp[1] = Piece.knight(true);
            let temp[2] = Piece.bishop(true);
            let temp[3] = Piece.queen(true);
            let temp[4] = Piece.king(true);
            let temp[5] = Piece.bishop(true);
            let temp[6] = Piece.knight(true);
            let temp[7] = Piece.rook(true);
        }

        return this;
    }

    method boolean isEven(int blah){

        return (blah - (2 * (blah / 2))) > 0;
    }

    method void makeMove(Move move) {
        // TODO add validation that the move is legal and even exists
        var Array rank;
        var Piece piece;

        let rank = ranks[move.getStartRank() - 1];
        let piece = rank[move.getStartFile() - 1];
        let rank[move.getStartFile() - 1] = 0;

        // TODO dispose of the piece that was there
        let rank = ranks[move.getEndRank() - 1];
        let rank[move.getEndFile() - 1] = piece;

        let hasChanges = true;

        return;
    }

    method void print(){
        var int i;
        var int j;
        var Array rank;
        var Piece piece;
        var boolean color;
        var boolean squareColor;
        var int dim;
        var int x1;
        var int x2;
        var int y1;
        var int y2;

        let i = 0;
        let color = true;
        let dim = 32;

        while (i < 8){
            let j = 0;
            while (j < 8){
                let squareColor = ~isEven(i + j);
                let color =squareColor;
                do Screen.setColor(color);
                // Add 8 to draw the board on the right side
                let x1 = (j + 8) * dim;
                // 7 - i so that we draw from white's perspective
                let y1 = (7 - i) * dim;
                let x2 = x1 + dim;
                let y2 = y1 + dim;

                do Screen.drawRectangle(x1, y1, x2-1, y2-1);

                let rank = ranks[i];
                let piece = rank[j];
                //do Screen.drawRectangle(x1, y1)
                if (~(piece = 0)){
                    do piece.draw(x1, y1, squareColor);
                }

                let j = j + 1;
            }

            let i = i + 1;
        }

        return;
    }

    method Piece getPieceAt(int x, int y) {
        var Array rank;
        let rank = ranks[y];
        return rank[y];
    }

    // squares, pseudoLegal, legal

    // x, y is in 0-based coordinates
    method Array getLegalMovesAt(int x, int y) {
        // i.e. could capture own piece, etc.
        var Array validSquares;
        var Array pseudoLegal;
        var Piece piece;
        var Square pos;
        var Array ret;

        let pos = Square.fromBoardIndices(x, y);
        // TODO optimize
        let ret = Array.new(32);

        let piece = getPieceAt(x, y);



        if (piece = 0) {
            return ret;
        }
        
        if (piece.isPawn()) {
            // return getLegalMovesForPawn(x, y, piece.getColor());
        }

        if (piece.isKnight()) {
            let validSquares = getKnightSquares(pos);
        }

        return ret;
    }

    // method Array getMoves

    method Array getKnightSquares(Square start) {
        var Square testSquare;
        var Array ret;
        var int index;

        let index = 0;


        // Maximum of 8, + 1 for the null marker
        let ret = Array.new(9);

        let testSquare = start.add(2, 3);
        if (testSquare.isOnBoard()) {
            let ret[index] = testSquare;
            let index = index + 1;
        }

        return ret;
    }

    method Array getRookSquares(Square start) {
        var Array ret;
        var Square testSquare;
        var int off;
        var int index;
        
        let off = 7;
        let ret = Array.new(32);
        let index = 0;

        while (off > -7) {
            let testSquare = start.add(off, 0);
            if (testSquare.isOnBoard()) {
                let ret[index] = testSquare;
                let index = index + 1;
            }
            
            let testSquare = start.add(0, off);
            if (testSquare.isOnBoard()) {
                let ret[index] = testSquare;
                let index = index + 1;
            }
        }

        return ret;
    }

    method Array getBishopSquares(Square start) {
        var Array ret;
        var Square testSquare;
        return ret;
    }

    // method Array getLegalMovesForPawn(int x, int y, boolean color) {
    //     if (y = )
    // }

}