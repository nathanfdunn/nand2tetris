class Board {
    field Array ranks;

    field boolean hasChanges;

    static boolean debug;

    // static int boardDim;

    function void init() {
        let debug = true;
        return;
    }

    // function boolean getDebug() {
    //     return debug;
    // }

    method boolean getHasChanges() {
        return hasChanges;
    }

    method void acknowledgeChanges() {
        let hasChanges = false;
        return;
    }

    method void touch() {
        let hasChanges = true;
        return;
    }

    constructor Board new(){
        var int i;
        var Array temp;
        let i = 0;
        let ranks = Array.new(8);

        let hasChanges = true;

        while (i < 8){
            let ranks[i] = Array.new(8);
            let i = i + 1;
        }

        if (debug) {
            let temp = ranks[3];
            let temp[3] = Piece.knight(true);
        }
        else {
            let temp = ranks[0];
            let temp[0] = Piece.rook(false);
            let temp[1] = Piece.knight(false);
            let temp[2] = Piece.bishop(false);
            let temp[3] = Piece.queen(false);
            let temp[4] = Piece.king(false);
            let temp[5] = Piece.bishop(false);
            let temp[6] = Piece.knight(false);
            let temp[7] = Piece.rook(false);

            let temp = ranks[1];
            let temp[0] = Piece.pawn(false);
            let temp[1] = Piece.pawn(false);
            let temp[2] = Piece.pawn(false);
            let temp[3] = Piece.pawn(false);
            let temp[4] = Piece.pawn(false);
            let temp[5] = Piece.pawn(false);
            let temp[6] = Piece.pawn(false);
            let temp[7] = Piece.pawn(false);

            let temp = ranks[6];
            let temp[0] = Piece.pawn(true);
            let temp[1] = Piece.pawn(true);
            let temp[2] = Piece.pawn(true);
            let temp[3] = Piece.pawn(true);
            let temp[4] = Piece.pawn(true);
            let temp[5] = Piece.pawn(true);
            let temp[6] = Piece.pawn(true);
            let temp[7] = Piece.pawn(true);

            let temp = ranks[7];
            let temp[0] = Piece.rook(true);
            let temp[1] = Piece.knight(true);
            let temp[2] = Piece.bishop(true);
            let temp[3] = Piece.queen(true);
            let temp[4] = Piece.king(true);
            let temp[5] = Piece.bishop(true);
            let temp[6] = Piece.knight(true);
            let temp[7] = Piece.rook(true);
        }

        return this;
    }

    method boolean isEven(int blah){

        return (blah - (2 * (blah / 2))) > 0;
    }

    method void makeMove(Move move) {
        // TODO add validation that the move is legal and even exists
        var Array rank;
        var Piece piece;

        let rank = ranks[move.getStartRank() - 1];
        let piece = rank[move.getStartFile() - 1];
        let rank[move.getStartFile() - 1] = 0;

        // TODO dispose of the piece that was there
        let rank = ranks[move.getEndRank() - 1];
        let rank[move.getEndFile() - 1] = piece;

        let hasChanges = true;

        return;
    }

    method void print(){
        var int i;
        var int j;
        var Array rank;
        var Piece piece;
        var boolean color;
        var boolean squareColor;
        var int dim;
        var int x1;
        var int x2;
        var int y1;
        var int y2;

        let i = 0;
        let color = true;
        let dim = 32;

        while (i < 8){
            let j = 0;
            while (j < 8){
                let squareColor = ~isEven(i + j);
                let color =squareColor;
                do Screen.setColor(color);
                // Add 8 to draw the board on the right side
                let x1 = (j + 8) * dim;
                // 7 - i so that we draw from white's perspective
                let y1 = (7 - i) * dim;
                let x2 = x1 + dim;
                let y2 = y1 + dim;

                do Screen.drawRectangle(x1, y1, x2-1, y2-1);

                let rank = ranks[i];
                let piece = rank[j];
                //do Screen.drawRectangle(x1, y1)
                if (~(piece = 0)){
                    do piece.draw(x1, y1, squareColor);
                }

                let j = j + 1;
            }

            let i = i + 1;
        }

        return;
    }

    method Piece getPieceAt(int x, int y) {
        var Array rank;
        let rank = ranks[y];
        return rank[y];
    }


    // TODO remove?    
    method void printLegalMovesAt(int x, int y) {
        var List moves;
        var int index;
        var Square square;
        let moves = getLegalMovesAt(x, y);

        if (moves = 0) {
            do Output.printString("NULL");
        }
        else {
            let index = moves.getLength() - 1;
            while (index > -1) {
                let square = moves.getElement(index);
                do Output.printString(square.toString());
                do Output.println();
                
                let index = index - 1;
            }
        }

        return;
    }

    // x, y is in 0-based coordinates
    // TODO return Moves instead of Squares
    method List getLegalMovesAt(int x, int y) {
        // i.e. could capture own piece, etc.
        var List offsets;
        var List pseudoLegal;
        var Piece piece;
        var Square pos;
        var Array ret;
        var int index;
        var Square potentialSquare;

        let piece = getPieceAt(x, y);

        if (piece = 0) {
            return 0;
        }

        let pos = Square.fromBoardIndices(x, y);

        let offsets = SquareGenerator.getOffsetsByPiece(piece);
        
        let pseudoLegal = List.empty();

        let index = offsets.getLength() - 1;

        while (index > -1) {
            let potentialSquare = offsets.getElement(index);
            let potentialSquare = potentialSquare.addSquare(pos);
            if (potentialSquare.isOnBoard()) {
                do pseudoLegal.append(potentialSquare);
            }

            let index = index - 1;
        }

        // TODO check legality

        return pseudoLegal;
        // return ret;
    }

    method Array getPotentialSquares(Square pos, Array offsets, int offsetsLength) {
        var Array ret;
        let ret = Array.new(offsetsLength);

        let offsetsLength = offsetsLength - 1;
        while (offsetsLength > -1) {
            let ret[offsetsLength] = pos.addSquare(offsets[offsetsLength]);
            let offsetsLength = offsetsLength - 1;
        }

        return ret;
    }

}